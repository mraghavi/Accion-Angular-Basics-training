<!-- Blog Post Header -->
<div class="container mt-4">
  <h1 class="display-4 text-center mb-4">ğŸŒŸ Mastering Template Driven Forms in Angular ğŸŒŸ</h1>
  <p class="lead text-center mb-4">
    In this guide, we'll dive into the world of Template Driven Forms in Angular and explore when and why to use them. 
    Whether you're a beginner or a seasoned Angular developer, understanding template-driven forms is crucial for building 
    effective and dynamic forms in your applications.
  </p>

  <!-- Introduction Section -->
  <section class="mb-5">
    <h2 class="display-5 text-primary">ğŸ“‹ What Are Template Driven Forms?</h2>
    <p class="lead">
      Imagine you're filling out a form at a hospital or school. You're given a paper to jot down your basic details, 
      which is later digitized into a system. In technical terms, Angular provides Template Driven Forms to facilitate 
      this process electronically. These forms are a natural way to gather and manage user input.
    </p>
    <p><strong>Note:</strong> To use forms in Angular, ensure you import the <code>FormsModule</code> .</p>
  </section>

  <!-- Features Section -->
  <section class="mb-5">
    <h2 class="display-5 text-success">ğŸŒˆ Features of Template Driven Forms</h2>
    <ul class="list-group mb-4">
      <li class="list-group-item"><i class="fa fa-check-circle text-primary"></i> User-Friendly: Easy to implement and ideal for straightforward use cases.</li>
      <li class="list-group-item"><i class="fa fa-check-circle text-primary"></i> Simplicity: Perfect for basic scenarios without complex requirements.</li>
      <li class="list-group-item"><i class="fa fa-check-circle text-primary"></i> Familiar Syntax: Uses a syntax similar to AngularJS.</li>
      <li class="list-group-item"><i class="fa fa-check-circle text-primary"></i> Two-Way Data Binding: Leverages <code>[(ngModel)]</code> for seamless data binding.</li>
      <li class="list-group-item"><i class="fa fa-check-circle text-primary"></i> Minimal Code: Requires less code in components.</li>
      <li class="list-group-item"><i class="fa fa-check-circle text-primary"></i> Automatic Tracking: Angular manages the form state and data automatically.</li>
      <li class="list-group-item"><i class="fa fa-check-circle text-primary"></i> Validation with Directives: Form validation is achieved through directives.</li>
      <li class="list-group-item"><i class="fa fa-check-circle text-primary"></i> Asynchronous Nature: Form predictability and validation are handled asynchronously.</li>
    </ul>
  </section>

  <!-- When to Use Section -->
  <section class="mb-5">
    <h3 class="display-6 text-warning">ğŸš€ When to Use Template Driven Forms</h3>
    <p>
      Opt for template-driven forms when you need simple and straightforward forms, such as sign-in or basic data collection forms.
    </p>
  </section>

  <!-- Example Form Section -->
  <section class="mb-5">
    <h3 class="display-6 text-info">âœ¨ Example Template Driven Form</h3>
    <form #form="ngForm" class="p-4 border rounded shadow-sm">
      <div class="form-row">
        <div class="form-group col-md-6">
          <label for="inputEmail4">Email</label>
          <input type="email" name="email" [(ngModel)]="templateObj.email" class="form-control" id="inputEmail4" placeholder="Email">
        </div>
        <div class="form-group col-md-6">
          <label for="inputPassword4">Password</label>
          <input type="password" name="password" [(ngModel)]="templateObj.password" class="form-control" id="inputPassword4" placeholder="Password">
        </div>
      </div>
      <div class="form-group">
        <label for="inputAddress">Address</label>
        <input type="text" name="address" #fAddress1="ngModel" [(ngModel)]="templateObj.address" class="form-control" id="inputAddress" required minlength="3" placeholder="1234 Main St">
        <div class="text-danger">
          <span *ngIf="(fAddress1.touched || fAddress1.dirty) && fAddress1.errors?.['required']">This is required</span>
          <span *ngIf="(fAddress1.touched || fAddress1.dirty) && fAddress1.errors?.['minlength']">Min 3 chars required</span>
        </div>
      </div>
      <div class="form-group">
        <label for="inputAddress2">Address 2</label>
        <input type="text" name="adress2" #fAddress="ngModel" [(ngModel)]="templateObj.adress2" class="form-control" required minlength="3" id="inputAddress2" placeholder="Apartment, studio, or floor">
        <div class="text-danger">
          <span *ngIf="(fAddress.touched || fAddress.dirty) && fAddress.errors?.['required']">This is required</span>
          <span *ngIf="(fAddress.touched || fAddress.dirty) && fAddress.errors?.['minlength']">Min 3 chars required</span>
        </div>
      </div>

      <div class="form-row">
        <div class="form-group col-md-6">
          <label for="inputCity">City</label>
          <input type="text" name="city" [(ngModel)]="templateObj.city" class="form-control" id="inputCity">
        </div>
        <div class="form-group col-md-4">
          <label for="inputState">State</label>
          <select class="form-control" name="state" [(ngModel)]="templateObj.state" id="inputState">
            <option>1</option>
            <option>2</option>
            <option>3</option>
            <option>4</option>
            <option>5</option>
          </select>
        </div>
        <div class="form-group col-md-2">
          <label for="inputZip">Zip</label>
          <input type="text" name="zipcode" [(ngModel)]="templateObj.zipcode" class="form-control" id="inputZip">
        </div>
      </div>
      <div class="form-group">
        <div class="form-check">
          <input name="checkbox" [(ngModel)]="templateObj.checkbox" class="form-check-input" type="checkbox" id="gridCheck">
          <label class="form-check-label" for="gridCheck">Check me out</label>
        </div>
      </div>
      <button type="submit" [disabled]="form.invalid" (click)="onClick()" class="btn btn-primary">Sign in</button>
      <button type="button" (click)="resetValue()" class="btn btn-secondary">Reset</button>
    </form>

    <div class="mt-5">
      <h3 class="text-info">ğŸ“œ Form Value Preview:</h3>
      <pre class="bg-light p-3 rounded">{{formValue | json}}</pre>
    </div>
  </section>

  <!-- Validators Section -->
  <section class="mb-5">
    <h2 class="display-5 text-danger">ğŸ—ï¸ Built-in Validators</h2>
    <p class="lead">
      Angularâ€™s built-in validators utilize HTML5 validation attributes like <code>required</code>, <code>minlength</code>, 
      <code>maxlength</code>, and <code>pattern</code>. Angular interprets these attributes to apply validation functions 
      to <code>FormControl</code> instances.
    </p>

    <h3 class="display-6 text-info">Required Validation</h3>
    <p>The <code>required</code> validator ensures that the form control has a non-empty value.</p>

    <h3 class="display-6 text-info">Minlength Validation</h3>
    <p>This validator requires that the control's value contains at least the specified number of characters.</p>

    <h3 class="display-6 text-info">Maxlength Validation</h3>
    <p>This validator ensures that the number of characters in the control does not exceed the specified limit.</p>
  </section>

  <!-- Conclusion Section -->
  <section class="mb-5">
    <h3 class="display-6 text-success">ğŸ¯ Conclusion</h3>
    <p class="lead">
      Template-driven forms leverage Angularâ€™s directives for model creation directly in the template, offering a simpler 
      approach for basic forms. They remain a powerful tool for simple scenarios, but for more complex requirements, Angularâ€™s 
      reactive forms provide a more robust solution.
    </p>
    <p class="lead">
      Embrace the simplicity of template-driven forms for your straightforward use cases, and consider reactive forms when you 
      need more control and scalability in your forms. Each approach has its strengths, so choose the one that best fits your 
      project needs.
    </p>
  </section>
</div>
